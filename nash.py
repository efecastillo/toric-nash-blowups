# -*- coding: utf-8 -*-
"""
Module for the computations of toric Nash blowups

EXAMPLES:

REFERENCES:

    - A. Atanasov, C. Lopez, A. Perry, N. Proudfoot, M. Thaddeus
      Resolving toric varieties with Nash blow-ups, arXiv:0910.5028

    - J. Liu, L. Trotter Jr.,  G. Ziegler
      On the Height of the Minimal Hilbert Basis

AUTHORS:

- Federico Castillo and Alvaro Liendo (2024): Initial version


VERSION:
    November 15, 2024
"""

##############################################################################
#     Copyright (C) 2024 Federico Castillo  <efecastillo.math at gmail.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#                  http://www.gnu.org/licenses/
##############################################################################


from helpers import *
from collections import deque

"""
Input: A cone generated by columns of a matrix
Must also state Characteristic of field (by default it is zero)

Output: A list with its children represented by matrices.
"""


def normalized_nash_blowup(cone, Char=0):
    hilbert_basis = Cone(cone.columns()).Hilbert_basis()

    # Creating the vertices for the polyhedron
    verts = []
    # dimension
    d = len(hilbert_basis[0])

    # Main loop
    for S in Subsets(hilbert_basis, d):
        rays = matrix(ZZ, S, immutable=True)

        if Char == 0:
            if rays.determinant() != 0:
                verts.append(sum(S))

        else:
            if mod(rays.determinant(), Char) != 0:
                verts.append(sum(S))

    # We create the unbounded polyhedron
    Q = Polyhedron(vertices=verts, rays=cone.columns())

    return tangent_cones(Q)

"""
Input: A semigroup generated by columns of a matrix
Characteristic is always zero

Output: A list with its children represented by matrices.
"""
def nonormalized_nash_blowup(semig):

    cols = set(semig.columns())
    dim = semig.nrows()
    children = []
    
    for I in Subsets(cols,dim):
        if matrix(ZZ,I).determinant() != 0:
            G_I = list(cols)
            for h in I:
                for g in cols:
                    if g in I: continue
                    J = set(I)
                    J.discard(h)
                    J.add(g)
                    if matrix(ZZ,J).determinant() != 0:
                        v = vector(g) - vector(h)
                        G_I.append(v)

            if Polyhedron(rays=G_I).lines(): continue

            semigroup_overshoot = matrix(ZZ,G_I).transpose()
            semig_new = reduction(semigroup_overshoot)
            children.append(semig_new)
    return children

"""
Input: A cone generated by columns of a matrix
Must also state Characteristic of field (by default it is zero)

Output: A list with its children represented by matrices in palp normal form
This is the function \chi in the paper
"""


def chi_cone(cone, Char=0):

    children = normalized_nash_blowup(cone, Char)

    return set((palp_cone(child) for child in children))

"""
Input: A semigrpup generated by columns of a matrix

Output: A list with its children represented by matrices in normal form
This is the function \chi in the paper
"""


def chi_semig(semig):

    children = nonormalized_nash_blowup(semig)

    return set((standard_semig(child) for child in children))

"""
Input: A cone generated by columns of a matrix
Must also state Characteristic of field (by default it is zero)

Output: Boolean depending on whether the whole tree creation was succesful or not

Side Effect: populate the database DB with the tree below the specified root.
"""


def normalized_nash_tree(root, DB=dict(), Char=0, Threshold=12):

    # root may not have the minimal generators
    cone_input = Cone(root.columns())

    if not cone_input.is_strictly_convex() or not cone_input.is_full_dimensional():
        print("Input is not strictly convex or full-dimensional")
        return False

    sanitized_seed = matrix(ZZ, cone_input.rays()).transpose()
    standard_seed = palp_cone(sanitized_seed)

    # If this is already in the database there is nothing to do
    if standard_seed in DB:
        return True

    # Initialize queue
    initial = standard_seed
    q = deque()
    q.append(initial)

    # Main loop
    while q:

        current = q.popleft()
        if current in DB:
            continue
        else:
            children = chi_cone(current)
            DB[current] = children
            for child in children:
                q.append(child)

    return True

"""
Input: A semigroup generated by columns of a matrix
*WARNING* no checks on the input
It can NOT contain a zero column
we assume that the root is already minimal

Output: Boolean depending on whether the whole tree creation was succesful or not

Side Effect: populate the database DB with the tree below the specified root.
"""

def nonormalized_nash_tree(root, DB=dict(), Char=0, Threshold=12):

    standard_seed = standard_semig(root)

    # If this is already in the database there is nothing to do
    if standard_seed in DB:
        return True

    # Initialize queue
    initial = standard_seed
    q = deque()
    q.append(initial)

    # Main loop
    while q:

        current = q.popleft()
        if current in DB:
            continue
        else:
            children = chi_semig(current)
            DB[current] = children
            for child in children:
                q.append(child)

    return True
