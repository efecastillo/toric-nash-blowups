# -*- coding: utf-8 -*-
'''
Module for the computations of toric Nash blowups

EXAMPLES:

REFERENCES:

    - A. Atanasov, C. Lopez, A. Perry, N. Proudfoot, M. Thaddeus
      Resolving toric varieties with Nash blow-ups, arXiv:0910.5028

    - J. Liu, L. Trotter Jr.,  G. Ziegler
      On the Height of the Minimal Hilbert Basis

AUTHORS:

- Federico Castillo and Alvaro Liendo (2025): Initial version


VERSION:
    November 24, 2025
'''

##############################################################################
#     Copyright (C) 2025 Federico Castillo  <efecastillo.math at gmail.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#                  http://www.gnu.org/licenses/
##############################################################################


from helpers import *
from collections import deque
from sage.graphs.digraph import DiGraph


'''
Input: A cone generated by columns of a matrix
Must also state Characteristic of field (by default it is zero)

Output: A list with its children represented by matrices.
'''


def cone_normalized_nash_blowup(cone, Char=0):
    hilbert_basis = Cone(cone.columns()).Hilbert_basis()

    # Creating the vertices for the polyhedron
    verts = []
    # dimension
    d = len(hilbert_basis[0])

    # Main loop
    for S in Subsets(hilbert_basis, d):
        rays = matrix(ZZ, S, immutable=True)

        if Char == 0:
            if rays.determinant() != 0:
                verts.append(sum(S))

        else:
            if rays.determinant()%Char != 0:
                verts.append(sum(S))

    # We create the unbounded polyhedron
    Q = Polyhedron(vertices=verts, rays=cone.columns())

    return tangent_cones(Q)


'''
Input: A cone generated by columns of a matrix
Must also state Characteristic of field (by default it is zero)

Output: A list with its children represented by matrices in palp normal form
This is the function \chi in the paper
'''


def cone_chi(cone, Char=0):

    children = cone_normalized_nash_blowup(cone, Char)

    return set((palp_cone(child) for child in children))
'''
Input: A cone generated by columns of a matrix
Must also state Characteristic of field (by default it is zero)

Output: Directed tree below the root

Side Effect: populate the database DB with the tree below the specified root.
'''


def cone_normalized_nash_tree(root, DB=None, Char=0):

    # If not given a database we create one
    DB = dict()

    # root may not have the minimal generators
    cone_input = Cone(root.columns())

    if not cone_input.is_strictly_convex() or not cone_input.is_full_dimensional():
        print("Input is not strictly convex or full-dimensional")
        return False

    sanitized_seed = matrix(ZZ, cone_input.rays()).transpose()
    standard_seed = palp_cone(sanitized_seed)

    # If this is already in the database there is nothing to do
    if standard_seed in DB:
        return DiGraph(DB)

    # Initialize queue
    initial = standard_seed
    q = deque()
    q.append(initial)

    # Main loop
    while q:

        current = q.popleft()
        if current in DB:
            continue
        else:
            children = cone_chi(current, Char)
            DB[current] = children
            for child in children:
                q.append(child)

    return DiGraph(DB)

'''
Input: A semigroup generated by columns of a matrix
Characteristic is always zero

Output: A list with its children represented by matrices.
'''
def semig_nash_blowup(semig):

    cols = set(semig.columns())
    dim = semig.nrows()
    children = []
    
    for I in Subsets(cols,dim):
        if matrix(ZZ,I).determinant() != 0:
            G_I = compute_GI(cols,set(I))
            if Polyhedron(rays=G_I).lines():
                continue

            semigroup_overshoot = matrix(ZZ,G_I).transpose()
            semig_new = reduction(semigroup_overshoot)
            children.append(semig_new)
    return children

'''
Input: A semigrpup generated by columns of a matrix

Output: A list with its children represented by matrices in normal form
This is the function \chi in the paper
'''


def semig_chi(semig):

    children = semig_nash_blowup(semig)

    return set((palp_semig(child) for child in children))


'''
Input: A semigroup generated by columns of a matrix
*WARNING* no checks on the input
It can NOT contain a zero column
we assume that the root is already minimal

Output: Boolean depending on whether the whole tree creation was succesful or not

Side Effect: populate the database DB with the tree below the specified root.
'''

def semig_nash_tree(root, DB=None):

    # If not given a database we create one
    DB = dict()

    standard_seed = palp_semig(root)

    # If this is already in the database there is nothing to do
    if standard_seed in DB:
        return DiGraph(DB)

    # Initialize queue
    initial = standard_seed
    q = deque()
    q.append(initial)

    # Main loop
    while q:

        current = q.popleft()
        if current in DB:
            continue
        else:
            children = semig_chi(current)
            DB[current] = children
            for child in children:
                q.append(child)

    return DiGraph(DB)
