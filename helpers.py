from sage.matrix.constructor import matrix
from sage.geometry.cone import Cone
from sage.geometry.polyhedron.base_ZZ import *
from sage.geometry.polyhedron.constructor import Polyhedron
from sage.geometry.fan_isomorphism import find_isomorphism
from sage.combinat.subset import Subsets
from itertools import product
from sage.geometry.fan import Fan


'''
Input: Integer vector
Output: Primite vector; i.e., with no common denom
'''


def primitive(v):
    d = gcd(v)
    if abs(d) > 1:
        return v / d
    else:
        return v


'''
Input: A polyhedron

Output: A list of its tangent cones at each vertex 
Each tangent cone is represented by a matrix where the columns are its generators
'''


def tangent_cones(Q):
    tcones = []
    for v in Q.vertices():
        temp = []
        for w in v.neighbors():
            if w.is_ray():
                temp.append(vector(w))
            else:
                temp.append(primitive(vector(w) - vector(v)))

        # Notice that by using primitive we are now sure that temp generates the desired ray
        # Without the use of primitive one gets immediate wrong results
        rays = matrix(ZZ, temp).transpose()
        tcones.append(rays)

    return tcones


'''
Input: A cone generated by columns of a matrix
Output: Boolean whether it is unimodular
'''


def is_unimodular(cone):
    if not cone.is_square():
        return False
    else:
        return abs(cone.determinant()) == 1


'''
Input: A cone generated by columns of a matrix
Output: PALP Normal form
'''


def palp_cone(cone):

    # Dimension
    dim = len(cone.rows())
    zero = vector(ZZ,dim)
    aux = cone.transpose()

    # This step adds the zero because normal forms needs
    # a full dimensional polytope
    P = Polyhedron( vertices = aux.insert_row(aux.nrows(), zero) ) 
    temp = P.normal_form()

    # We need to remove zero
    normal = matrix(ZZ, [col for col in temp if col!=zero])
    normal_transpose = matrix(ZZ, normal.columns(), immutable=True)
    return normal_transpose


'''
----------------------------------------------------------
|
| Below are the helper functions for the semigroup case
|
----------------------------------------------------------
'''


'''
Input: A semigruoup generators as columns of a matrix
Output: A matrix with minimal generators
'''

def reduction(semig, check_pointed=False, check_generate=False):

    dim = semig.nrows()
    
    #If we need to check for pointed
    if check_pointed:
        K = Polyhedron(rays=semig.columns())
        if K.lines():
            return False
        
    #If we need to check it generates the ambient space
    if check_generate:
        reduced = semig.LLL()

        #Zeros are at the start and the potential basis is at the end
        basis = reduced.rows()[-dim:]
        if matrix(ZZ,Base).determinant() not in (1,-1):
            return False
        
    #Sieving step
    cols = set(semig.columns())
    agregate = set(cols)
    BOUND = 6
    i = 0
    while i < BOUND:
        new_sums = sum_pair(agregate,cols)
        cols = cols - new_sums
        agregate = new_sums.copy()
        i+=1

    #Discard the ones that are redundant
    minimals = []
    for v in cols:
        if not redundant(cols,v):
            minimals.append(list(v))
    
    return matrix(ZZ, minimals, immutable=True).transpose()

'''
Auxilliary to the above function
'''
def sum_pair(S,T):
    ret = set()
    for s in S:
        for t in T:
            a=s+t
            a.set_immutable()
            ret.add(a)
    return ret


'''
Input: A set of vectors and an element of the set
Output: True or False depending on whether v is in the cone genetared by the set
'''

def redundant(S, v):
    dim = len(v)
    cols = S.copy()
    cols.remove(v)
    M = matrix(ZZ,cols).transpose()

    #Equalities
    constraints = []
    for i in range(dim):
        constraints.append([-v[i]]+list(M.row(i)))
    
    #Inequalities
    nnegatives=[]
    l = len(S)
    for i in range(1,l):
        temp = [0 for _ in range(l)]
        temp[i]=1
        nnegatives.append(temp)

    P = Polyhedron(eqns=constraints, ieqs=nnegatives)

    if P.integral_points_count():
        return True
    else:
        return False


'''
Input: A set of vectors and a subset of it
Output: ???
'''

def compute_GI(cols,I):
    G_I = list(cols)
    for h in I:
        for g in cols:
            if g in I:
                continue
            J = list(I)
            J.remove(h)
            J.append(g)
            if matrix(ZZ,J).determinant() != 0:
                v = vector(g) - vector(h)
                G_I.append(v)

    return G_I
    
'''
Input: A semigroup as a matrix
Output: A normal form of it
'''
def palp_semig(semig):    
    dim = semig.nrows()
    zero = vector(ZZ,dim)
    aux = semig.transpose()

    #Auxilliary: we add the zero to ensure that it is full dimensional
    #note that zero will always be a vertex if the semigroup is pointed


    P = Polyhedron( vertices = aux.insert_row(aux.nrows(), vector(zero) ) ) 
    _, pi = P.normal_form(permutation=True)

    M = matrix(ZZ, pi(P.vertices())).transpose()
    _, U = M.hermite_form(transformation=True) 

    T = U*semig
    R = matrix( ZZ, sorted(T.columns()), immutable=True )
    return matrix( ZZ, R.columns(), immutable=True)

