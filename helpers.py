from sage.matrix.constructor import matrix
from sage.geometry.cone import Cone
from sage.geometry.polyhedron.base_ZZ import *
from sage.geometry.polyhedron.constructor import Polyhedron
from sage.geometry.fan_isomorphism import find_isomorphism
from sage.combinat.subset import Subsets
from itertools import product
from sage.geometry.fan import Fan


'''
Input: Integer vector
Output: Primite vector; i.e., with no common denom
'''


def primitive(v):
    d = gcd(v)
    if abs(d) > 1:
        return v / d
    else:
        return v


'''
Input: A polyhedron

Output: A list of its tangent cones at each vertex 
Each tangent cone is represented by a matrix where the columns are its generators
'''


def tangent_cones(Q):
    tcones = []
    for v in Q.vertices():
        temp = []
        for w in v.neighbors():
            if w.is_ray():
                temp.append(vector(w))
            else:
                temp.append(primitive(vector(w) - vector(v)))

        # Notice that by using primitive we are now sure that temp generates the desired ray
        # Without the use of primitive one gets immediate wrong results
        rays = matrix(ZZ, temp).transpose()
        tcones.append(rays)

    return tcones


'''
Input: A cone generated by columns of a matrix
Output: Boolean whether it is unimodular
'''


def is_unimodular(cone):
    if not cone.is_square():
        return False
    else:
        return abs(cone.determinant()) == 1


'''
Input: A cone generated by columns of a matrix
Output: PALP Normal form
'''


def palp_cone(cone):
    # Dimension
    d = len(cone.rows())

    # Artificially create a zero vector
    zero = [0 for i in range(d)]

    # This step adds the zero because normal forms needs
    # a full dimensional polytope
    P = Polyhedron(vertices=cone.columns() + [zero])
    temp = P.normal_form()

    # In a hacky way we remove the zero vector and return
    N = matrix(ZZ, temp, immutable=True).transpose()
    cols = N.columns()
    lis = []
    for i in range(len(cols)):
        if cols[i] == vector(zero):
            lis.append(i)
            N = N.delete_columns(lis)
            break

    return N.hermite_form()


'''
Input: A semigruoup generators as columns of a matrix
Output: A matrix with minimal generators
'''

def reduction(semig, check_pointed=False, check_generate=False):

    dim = semig.nrows()
    
    #If we need to check for pointed
    if check_pointed:
        K = Polyhedron(rays=semig.columns())
        if K.lines():
            return False
        
    #If we need to check it generates the ambient space
    if check_generate:
        reduced = semig.LLL()

        #Zeros are at the start and the potential basis is at the end
        basis = reduced.rows()[-dim:]
        if matrix(ZZ,Base).determinant() not in (1,-1):
            return False
        
    #Sieving step
    cols = set(semig.columns())
    agregate = set(cols)
    BOUND = 6
    i = 0
    while i < BOUND:
        new_sums = sum_pair(agregate,cols)
        cols = cols - new_sums
        agregate = new_sums.copy()
        i+=1

    #Discard the ones that are redundant
    minimals = []
    for v in cols:
        if not redundant(cols,v):
            minimals.append(list(v))
    
    return matrix(ZZ, minimals, immutable=True).transpose()

'''
Auxilliary
'''
def sum_pair(S,T):
    ret = set()
    for s in S:
        for t in T:
            a=s+t
            a.set_immutable()
            ret.add(a)
    return ret


'''
Input: A set of vectors and an element of the set
Output: True or False depending on whether v is in the cone genetared by the set
'''

def redundant(S, v):
    dim = len(v)
    cols = S.copy()
    cols.remove(v)
    M = matrix(ZZ,cols).transpose()

    #Equalities
    constraints = []
    for i in range(dim):
        constraints.append([-v[i]]+list(M.row(i)))
    
    #Inequalities
    nnegatives=[]
    l = len(S)
    for i in range(1,l):
        temp = [0 for _ in range(l)]
        temp[i]=1
        nnegatives.append(temp)

    P = Polyhedron(eqns=constraints, ieqs=nnegatives)

    if P.integral_points_count():
        return True
    else:
        return False


'''
Input: A set of vectors and a subset of it
Output: ???
'''

def compute_GI(cols,I):

    GI = cols.copy()
    
    for i in I:
        for j in cols:
            if j in I:
                continue

            M = [k for k in I if k!=i]+[j]

            if matrix(ZZ,M).determinant()!=0:
                r = vector(j)-vector(i)
                GI.add(j)

                
    return list(GI)


'''
Input: Two semigroups
Output: Boolean whether or not they are isomorphic
'''

def check_isomorfismo(semig1,semig2):
    C1 = Cone(semig1)
    C2 = Cone(semig2)
    A = find_isomorphism(Fan([C1]),Fan([C2])).matrix().transpose()
    S1 = set([immutabilize(x) for x in (A*matrix(ZZ,semig1).transpose()).columns()])
    S2 = set([immutabilize(x) for x in matrix(ZZ,semig2).transpose().columns()])
    return S1 == S2

'''
Auxilliary to make something immutable
'''

def immutabilize(m):
    M = copy(m)
    M.set_immutable()
    return M


'''
Input: A semigroup
Output: A normal form of it
'''
def standard_semig(semig):    
    C1 = Cone(palp_cone(matrix(ZZ,semig).transpose()).columns())
    C2 = Cone(semig)
    A = find_isomorphism(Fan([C2]),Fan([C1])).matrix().transpose()
    M = matrix(ZZ, sorted([list(x) for x in (A*matrix(ZZ,semig).transpose()).columns()], reverse=True), immutable=True)
    return  M
